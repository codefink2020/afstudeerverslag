
\chapter{Onderzoek: Methode extactie project dependency informatie}\label{ch:onderzoek:-methode-extactie-project-dependency-informatie}

Nu er een selectie is gemaakt in tooling om analyses te doen op dependencies binnen projecten moet er uitgezocht worden welke methode er het beste past om deze tools te gebruiken. In dit hoofdstuk wordt dan ook de onderzoeksvraag: "Hoe kan er middels de in het vorige onderzoek gevonden methoden gegevens over dependencies worden opgeslagen?"
Deze hoofdvraag roept een aantal deelvragen op die ieders beantwoord dienen te worden:
\begin{itemize}
    \item Hoe kunnen de methodes worden geimplementeerd, en welke output kunnen we verwachten?
    \item Welke data kan er verwacht worden uit de resultaten en hoe kan deze het beste worden opgeslagen.
    \item Wat is de meest efficiente manier om dependencies in een project te analyseren in?
\end{itemize}
Gezien dit onderzoek gaat over twee tools worden deze apart van elkaar behandeld en zal iedere hoofdvraag 2 keer worden beantwoord. De conclussie van dit hoofdstuk zal als basis worden gelegd voor het ontwerp dat in het volgende deel wordt getoont. De manier van onderzoeken is het verkrijgen van inzichten en resultaten middels het bouwen van een prototype. In deze prototype wordt gekeken hoe de tools zich gedragen en welke instellingen er nodig zijn om de tools voor de module inzetbaar te maken.

\section{Test opstelling}\label{sec:test-opstelling}
\sebsection{testdoelen}
\begin{itemize}
    \item uitzoeken wat de tools  minmaal nodig hebben om de gewenste resultaten te genereren.
    \item
\end{itemize}



Om te kunnen onderzoeken hoe de tools werken is er een testomgeving opgezet op mijn eigen machine. Omgevingen zijn op dit moment hetzelfde als op de Jenkins server. Op deze manier kunnen er de volgende projecten worden opgezet:
\begin{itemize}
    \item \textbf{API}: Dit is een "wegwerp prototype om te onderzoeken hoe de tooling zich gedraagd ten opzichte van onze dev-stack. DE API zal worden geschreven in Scala en gebruik maken van het playFramework om er een webservice van te ontwikkelen.
    \item \textbf{test frontend project}: Een angular applicatie met daarnaast een aantal bibliotheken waarvan bekend is dat mogelij kwetsbaarhden bevatten.
    \item \textbf{Test backend project}: Scala/PlayFramework backend met bibliotheken die potentieel een aantal krwetsbaarhden bevatten.
\end{itemize}
Er is gekozen voor bibliotheken waarvan bekend is dat deze kwetsbaarheden in verschillende niveau's bevatten dit omdat er dan een breder vlak is om te testen. er kan gekeken worden naar de verschillende niveau's en hoe de module hierop kan reageren. Let wel dat deze projecten nooit en te nimmer in productie zullen draaien en zo geen mogelijkheden hebben om schade toe te brengen aan omgevingen.



\section{SBT-Dependency-check voor SBT Projecten}\label{sec:sbt-dependency-check-voor-sbt-projecten}
Zoals eerder vermeld dient het project representatief te zijn voor de projecten die al gedraaid worden binnen EagleScience. Het is echter niet nodig om alle bibliotheken die we gebruiken te te voegen aan het project. Deze testcase gaat ervan uit dat playFramework wordt gebruikt met daarbij een aantal bibliotheken waarvan de inschatting is dat in deze projecten een aantal kwetsbaarheden zitten die niet worden benut. Het is ook niet nodig om een "werkend" project te hebben om de tooling te testen.

\subsection{Opzetten van een SBT project}\label{subsec:opzetten-van-een-project}
middels inteliJ is een nieuwe play project opgezet:
\begin{figure}[H]
    \centering
    \includegraphics[width=10cm]{gfx/sbtplaysetup}
    \caption{SBT PlayFramework2.x setup screen 1}
    \label{fig:sbtplaysetupscreen1}
\end{figure}
Vervolgens zijn er een aantal dependencies aan het project toegevoegd:
\begin{lstlisting}[caption={build.sbt},label=lst:build.sbt]
name := "testPlayFramework"
version := "1.0"
lazy val `testplayframework` = (project in file(".")).enablePlugins(PlayScala)
resolvers += "Akka Snapshot Repository" at "https://repo.akka.io/snapshots/"
scalaVersion := "2.13.5"

libraryDependencies ++= Seq(jdbc, ehcache, ws, specs2 % Test, guice,
"com.typesafe.play" %% "play" % "2.8.8",
"com.typesafe.play" %% "play-json" % "2.9.2",
"com.typesafe.play" %% "play-test" % "2.8.8" % "test",
"org.scalatestplus.play" %% "scalatestplus-play" % "5.1.0" % "test",

"org.scalikejdbc" %% "scalikejdbc" % "3.5.0",
"com.h2database" % "h2" % "1.4.200",
"ch.qos.logback" % "logback-classic" % "1.2.3",
)

\end{lstlisting}
In deze snippet is te zien dat er een aantal bibliotheken zijn toegevoegd, in het project worden deze niet gebruikt, alleen maar als dependency om te kunnen scannen.


\subsection{setup SBT-Dependency Check}\label{subsec:setup-sbt-dependency-check}
Om SBT-dependency-check te kunnen gebruiken moet er een plugin worden toegvoegd. deze wordt toegevoegd aan de plugins.sbt in de project folder zoals hieronder te zien.
\begin{lstlisting}[caption={plugin.sbt.sbt},label=lst:plugin.sbt]
logLevel := Level.Warn

resolvers += "Typesafe repository" at "https://repo.typesafe.com/typesafe/releases/"

addSbtPlugin("com.typesafe.play" % "sbt-plugin" % "2.8.8")
addSbtPlugin("net.vonbuchholtz" % "sbt-dependency-check" % "3.2.0")


\end{lstlisting}
Op het moment dat de plugin vermeld staat in plugins.sbt dan heeft SBT de mogelijkheid om taken die in de plugin staat uit te voeren. Door de taak \texttt{sbt dependencyCheck} uit te voeren wordt er een rapport in HTML uitgegeven. Echter willen we een output in JSON waar we verder mee kunnen werken in de API.

in de build.sbt dienen we de volgende regel \texttt{dependencyCheckFormat := "JSON"} toe te voegen om een JSON bestand uit de tool te verkrijgen.

\subsection{resultaten}\label{subsec:SBTResultaten}
Het resultaat is een JSON bestand welke gegevens bevat van alle dependencies welke door de tool zijn geannalyseert in deze json worden ook alle kwetsbaarheden per dependency uiteengezet.


\section{NPM -audit voor Node/AngularProjecten}\label{sec:npm--audit-voor-node/angularprojecten}
Angular project opgezet middels de IntelliJ wizard.

\subsection{Opzetten van een Angular project}\label{subsec:opzetten-van-een-project-ang}

\subsection{setup NPM-audit}\label{subsec:setup-npm-audit}
NPM audit is al inbegrepen in de toolset van NPM dus kan ieder moment aangeroepen worden middels \texttt{npm -audit} als we een JSON output willen dienen we de glad \texttt{--json toe te voegen. }
Het probleem is alleen dat deze manier van werken geen artifact opleverd in een bestand maar alleen een screendump.
Door deze te "pipen" naar een bestand kunnen we de dump veilig stellen.
\subsection{resultaten}\label{subsec:ang-resultaten}
De resulataten van Json zijn ook in Json en goed te gebruiken om in een database te zetten.



\section{Test API}\label{sec:test-api}
De volgende stap om te kijken of er op een manier getriggerd kan worden wanneer een sbt wordt opgehaald.
